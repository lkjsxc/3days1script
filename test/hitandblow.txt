// ========================================================================
// Function Definitions
// ========================================================================

// fn print_char ( char_code )
// Prints a single character given its ASCII code.
// Input: char_code (integer ASCII value)
// Output: None (writes to output 1)
fn print_char ( char_code ) {
    write ( 1 char_code )
    return 0 // Return dummy value
}

// fn print_newline ( )
// Prints a newline character (ASCII 10).
// Input: None
// Output: None (writes to output 1)
fn print_newline ( ) {
    write ( 1 10 )
    return 0 // Return dummy value
}

// fn print_int ( n )
// Prints an integer value. Handles 0 and positive integers.
// Input: n (integer)
// Output: None (writes to output 1)
fn print_int ( n ) {

    // Handle zero separately
    if n == 0 {
        print_char ( 48 ) // '0'
        return 0
    }

    // // Handle negative (not strictly needed for hits/blows, but good practice)
    // if n < 0 {
    //     print_char ( 45 ) // '-'
    //     &n = -n
    // }

    // Find the largest power of 10 smaller than or equal to n
    &divisor = 1
    loop {
        if n / divisor < 10 {
            break
        }
        // Prevent potential overflow if n is very large, though unlikely here
        if divisor > 1000000000 { // Check before multiplying
             break
        }
        &divisor = divisor * 10
    }

    // Print digits from left to right
    loop {
        &digit = n / divisor
        print_char ( digit + 48 ) // Add 48 to get ASCII code '0'..'9'

        // Remove the printed digit
        &n = n - digit * divisor // More robust than n = n % divisor for some simple interpreters

        // Move to the next digit position
        &divisor = divisor / 10
        if divisor == 0 {
            break
        }
    }
    return 0
}

// fn read_digit ( )
// Reads from input 0, skips spaces (32) and newlines (10),
// returns the first digit character found as an integer (0-9).
// Input: None (reads from input 0)
// Output: Integer value of the digit (0-9), or -1 if EOF/error (simplified: assumes valid input)
fn read_digit ( ) {
    &char_code = 0
    loop {
        &char_code = read ( 0 )

        // Basic check for EOF or error (assuming read returns < 0 or specific value)
        // This language might not have explicit EOF. Let's assume valid input for simplicity.
        // if char_code < 0 { return -1 } // Example error check

        // Check if it's a digit '0' (48) to '9' (57)
        if char_code >= 48 {
            if char_code <= 57 {
                &digit_value = char_code - 48
                return digit_value // Found a digit, return its integer value
            }
        }

        // Skip spaces and newlines, loop otherwise
        if char_code == 32 {
            // continue loop
        } else if char_code == 10 {
            // continue loop
        } else {
            // Optional: handle unexpected characters? For simplicity, just keep reading.
        }
    }
    // Should not be reached if input is guaranteed
    return -1 // Indicate error/unexpected end
}


// fn calculate_hits_blows ( s1 s2 s3 s4 g1 g2 g3 g4 hits_ref blows_ref )
// Calculates hits and blows for the given secret and guess.
// Updates the values pointed to by hits_ref and blows_ref.
// Input: secret digits (s1..s4), guess digits (g1..g4)
//        references/pointers to store results (hits_ref, blows_ref)
// Output: None (modifies memory at hits_ref, blows_ref)
// Note: This version simulates passing by reference using memory addresses.
fn calculate_hits_blows ( s1 s2 s3 s4 g1 g2 g3 g4 hits_ref blows_ref ) {

    &hits = 0
    &blows = 0

    // Use temporary marker arrays (simulated with individual vars)
    // 0 = not used, 1 = used
    &s_used1 = 0
    &s_used2 = 0
    &s_used3 = 0
    &s_used4 = 0
    &g_used1 = 0
    &g_used2 = 0
    &g_used3 = 0
    &g_used4 = 0

    // --- First Pass: Calculate Hits ---
    // Check position 1
    if s1 == g1 {
        &hits = hits + 1
        &s_used1 = 1
        &g_used1 = 1
    }
    // Check position 2
    if s2 == g2 {
        &hits = hits + 1
        &s_used2 = 1
        &g_used2 = 1
    }
    // Check position 3
    if s3 == g3 {
        &hits = hits + 1
        &s_used3 = 1
        &g_used3 = 1
    }
    // Check position 4
    if s4 == g4 {
        &hits = hits + 1
        &s_used4 = 1
        &g_used4 = 1
    }

    // --- Second Pass: Calculate Blows ---
    // Compare guess digit 1 (if not used in a hit) with other secret digits
    if g_used1 == 0 {
        if s_used2 == 0 { if g1 == s2 { &blows = blows + 1 &s_used2 = 1 &g_used1 = 1 } } // Mark secret used
        if g_used1 == 0 { if s_used3 == 0 { if g1 == s3 { &blows = blows + 1 &s_used3 = 1 &g_used1 = 1 } } }
        if g_used1 == 0 { if s_used4 == 0 { if g1 == s4 { &blows = blows + 1 &s_used4 = 1 &g_used1 = 1 } } }
    }
    // Compare guess digit 2 (if not used in a hit)
    if g_used2 == 0 {
        if s_used1 == 0 { if g2 == s1 { &blows = blows + 1 &s_used1 = 1 &g_used2 = 1 } }
        if g_used2 == 0 { if s_used3 == 0 { if g2 == s3 { &blows = blows + 1 &s_used3 = 1 &g_used2 = 1 } } }
        if g_used2 == 0 { if s_used4 == 0 { if g2 == s4 { &blows = blows + 1 &s_used4 = 1 &g_used2 = 1 } } }
    }
    // Compare guess digit 3 (if not used in a hit)
    if g_used3 == 0 {
        if s_used1 == 0 { if g3 == s1 { &blows = blows + 1 &s_used1 = 1 &g_used3 = 1 } }
        if g_used3 == 0 { if s_used2 == 0 { if g3 == s2 { &blows = blows + 1 &s_used2 = 1 &g_used3 = 1 } } }
        if g_used3 == 0 { if s_used4 == 0 { if g3 == s4 { &blows = blows + 1 &s_used4 = 1 &g_used3 = 1 } } }
    }
    // Compare guess digit 4 (if not used in a hit)
    if g_used4 == 0 {
        if s_used1 == 0 { if g4 == s1 { &blows = blows + 1 &s_used1 = 1 &g_used4 = 1 } }
        if g_used4 == 0 { if s_used2 == 0 { if g4 == s2 { &blows = blows + 1 &s_used2 = 1 &g_used4 = 1 } } }
        if g_used4 == 0 { if s_used3 == 0 { if g4 == s3 { &blows = blows + 1 &s_used3 = 1 &g_used4 = 1 } } }
    }

    // Store results back into the memory locations provided
    *hits_ref = hits    // Correct: Store value AT the address hits_ref
    *blows_ref = blows  // Correct: Store value AT the address blows_ref

    return 0 // Return dummy value
}


// ========================================================================
// Main Processing Logic
// ========================================================================

// --- Configuration ---
&CODE_LEN = 4       // Length of the secret code
&MAX_ATTEMPTS = 10  // Maximum number of guesses allowed

// --- Secret Code ---
// Hardcoded for simplicity. Choose 4 digits (0-9). Can repeat.
&secret1 = 1
&secret2 = 3
&secret3 = 5
&secret4 = 7

// --- Game State Variables ---
&attempts = 0
造t_hits = 0
造t_blows = 0

// --- Memory Allocation for Results ---
// Allocate memory space for hits and blows results, similar to cache_ptr example
&results_storage = * 2     // Allocate 2 integer slots
&hits_ptr = results_storage    // Address for hits result
&blows_ptr = results_storage + 1 // Address for blows result
// Initialize allocated memory (good practice, though 0 is default)
*hits_ptr = 0
*blows_ptr = 0

// --- Welcome Message ---
// H i t   a n d   B l o w
print_char ( 72 ) print_char ( 105 ) print_char ( 116 ) print_char ( 32 )
print_char ( 97 ) print_char ( 110 ) print_char ( 100 ) print_char ( 32 )
print_char ( 66 ) print_char ( 108 ) print_char ( 111 ) print_char ( 119 )
print_newline ( )
// G u e s s   t h e   4   d i g i t   c o d e .
print_char ( 71 ) print_char ( 117 ) print_char ( 101 ) print_char ( 115 ) print_char ( 115 ) print_char ( 32 )
print_char ( 116 ) print_char ( 104 ) print_char ( 101 ) print_char ( 32 )
print_char ( 52 ) print_char ( 32 ) // 4
print_char ( 100 ) print_char ( 105 ) print_char ( 103 ) print_char ( 105 ) print_char ( 116 ) print_char ( 32 )
print_char ( 99 ) print_char ( 111 ) print_char ( 100 ) print_char ( 101 ) print_char ( 46 ) // .
print_newline ( )
print_newline ( )


// --- Game Loop ---
loop {
    // Check if game won *before* checking attempts limit (to allow winning on last try)
    if current_hits == CODE_LEN {
         // W i n !
        print_char ( 87 ) print_char ( 105 ) print_char ( 110 ) print_char ( 33 )
        print_newline ( )
       break // Exit game loop
    }

    // Check if max attempts reached
    if attempts >= MAX_ATTEMPTS {
        // L o s t !
        print_char ( 76 ) print_char ( 111 ) print_char ( 115 ) print_char ( 116 ) print_char ( 33 )
        print_newline ( )
        // S e c r e t   w a s :
        print_char ( 83 ) print_char ( 101 ) print_char ( 99 ) print_char ( 114 ) print_char ( 101 ) print_char ( 116 ) print_char ( 32 )
        print_char ( 119 ) print_char ( 97 ) print_char ( 115 ) print_char ( 58 ) print_char ( 32 ) // : space
        print_int ( secret1 ) print_char ( 32 )
        print_int ( secret2 ) print_char ( 32 )
        print_int ( secret3 ) print_char ( 32 )
        print_int ( secret4 )
        print_newline ( )
        break // Exit game loop
    }


    // --- Start Next Attempt ---
    &attempts = attempts + 1

    // Print attempt number
    // A t t e m p t < > :
    print_char ( 65 ) print_char ( 116 ) print_char ( 116 ) print_char ( 101 ) print_char ( 109 ) print_char ( 112 ) print_char ( 116 ) print_char ( 32 )
    print_int ( attempts )
    print_char ( 58 ) print_char ( 32 ) // : space

    // --- Read Guess ---
    // Prompt is implicitly the attempt number line ending in ": "
    &guess1 = read_digit ( )
    &guess2 = read_digit ( )
    &guess3 = read_digit ( )
    &guess4 = read_digit ( )

    // --- Calculate Hits and Blows ---
    // Call the function, passing the memory addresses for results
    &status = calculate_hits_blows ( secret1 secret2 secret3 secret4 guess1 guess2 guess3 guess4 hits_ptr blows_ptr )

    // Read the results back from memory
    造t_hits = * hits_ptr
    造t_blows = * blows_ptr

    // --- Print Results ---
     // H i t s : < > ,   B l o w s : < >
    print_char ( 72 ) print_char ( 105 ) print_char ( 116 ) print_char ( 115 ) print_char ( 58 ) print_char ( 32 ) // Hits:
    print_int ( current_hits )
    print_char ( 44 ) print_char ( 32 ) // , space
    print_char ( 66 ) print_char ( 108 ) print_char ( 111 ) print_char ( 119 ) print_char ( 115 ) print_char ( 58 ) print_char ( 32 ) // Blows:
    print_int ( current_blows )
    print_newline ( )
    print_newline ( ) // Add extra space between attempts

} // End of game loop

// --- End of Program ---
// Optional: return a status like the example
// &final_status = 0